#version 450

struct Edge {
    int start;
    int end;
    int weight;
};

layout(local_size_x = 1024) in;

// Input buffers
layout(std430, binding = 0) buffer EdgeList { Edge edges[]; };
layout(std430, binding = 1) buffer HasKeyword { uint hasKeyword[]; };

// Double-buffered distance and predecessor arrays
layout(std430, binding = 2) buffer Dist0 { uint dist0[]; };
layout(std430, binding = 3) buffer Dist1 { uint dist1[]; };
layout(std430, binding = 4) buffer Pred0 { int pred0[]; };
layout(std430, binding = 5) buffer Pred1 { int pred1[]; };

// Output buffers
layout(std430, binding = 6) buffer OutputDist { uint outputDist[]; };
layout(std430, binding = 7) buffer OutputPred { int outputPred[]; };

uniform uint V; 
uniform uint E; 
uniform uint W;
uniform uint BIG_NUMBER = 0x7FFFFFFF; // Safe maximum value

void main() {
    uint w = gl_WorkGroupID.x;        // Keyword index
    uint localID = gl_LocalInvocationID.x;
    uint N = gl_WorkGroupSize.x;      // Threads per work group

    // Initialize buffers for current keyword
    for (uint v = localID; v < V; v += N) {
        uint idx = w * V + v;
        if (hasKeyword[idx] != 0) {
            dist0[idx] = 0;
            dist1[idx] = 0;
            pred0[idx] = int(v);
            pred1[idx] = int(v);
        } else {
            dist0[idx] = BIG_NUMBER;
            dist1[idx] = BIG_NUMBER;
            pred0[idx] = -1;
            pred1[idx] = -1;
        }
    }

    barrier();
    memoryBarrier();

    for (uint iter = 0; iter < V; iter++) {
        uint currentBuf = iter % 2;   // 0: dist0/pred0, 1: dist1/pred1
        uint nextBuf = 1 - currentBuf; // Next buffer to update

        for (uint e = localID; e < E; e += N) {
            Edge edge = edges[e];
            uint u = uint(edge.start);
            uint v = uint(edge.end);
            uint weight = uint(edge.weight);
            uint idx_u = w * V + u;

            // Read distance from current buffer
            uint dist_u = (currentBuf == 0) ? dist0[idx_u] : dist1[idx_u];
            if (dist_u == BIG_NUMBER) continue; // Skip unreachable

            uint candidate = dist_u + weight;
            if (candidate > BIG_NUMBER) continue; // Avoid overflow

            // Update next buffer using atomicMin
            uint idx_v = w * V + v;
            if (nextBuf == 0) {
                uint oldDist = atomicMin(dist0[idx_v], candidate);
                if (candidate < oldDist) {
                    pred0[idx_v] = int(edge.start);
                }
            } else {
                uint oldDist = atomicMin(dist1[idx_v], candidate);
                if (candidate < oldDist) {
                    pred1[idx_v] = int(edge.start);
                }
            }
        }

        barrier();
        memoryBarrier();
    }

    // Copy results to output buffers
    uint resultBuf = V % 2; // Determine final buffer (0: dist0/pred0, 1: dist1/pred1)
    for (uint v = localID; v < V; v += N) {
        uint idx = w * V + v;
        if (resultBuf == 0) {
            outputDist[idx] = dist0[idx];
            outputPred[idx] = pred0[idx];
        } else {
            outputDist[idx] = dist1[idx];
            outputPred[idx] = pred1[idx];
        }
    }
}
